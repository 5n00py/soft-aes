use crate::aes::{
    aes_dec_block, aes_enc_block, AES_128_KEY_SIZE, AES_192_KEY_SIZE, AES_256_KEY_SIZE,
    AES_BLOCK_SIZE,
};

// The reference values for these test cases are taken from CryptoTool's
// AES step-by-step tool:
// https://www.cryptool.org/en/cto/aes-step-by-step

#[test]
fn test_aes_enc_block_key_len_128() {
    let plaintext: [u8; AES_BLOCK_SIZE] = [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];
    let key: [u8; AES_128_KEY_SIZE] = [
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee,
        0xff,
    ];
    let expected_ciphertext: [u8; AES_BLOCK_SIZE] = [
        0xfd, 0xe4, 0xfb, 0xae, 0x4a, 0x09, 0xe0, 0x20, 0xef, 0xf7, 0x22, 0x96, 0x9f, 0x83, 0x83,
        0x2b,
    ];

    let ciphertext = aes_enc_block(&plaintext, &key).expect("Encryption failed");
    assert_eq!(ciphertext, expected_ciphertext);
}

#[test]
fn test_aes_enc_block_key_len_192() {
    let plaintext: [u8; AES_BLOCK_SIZE] = [
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
        0x11,
    ];
    let key: [u8; AES_192_KEY_SIZE] = [
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee,
        0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
    ];
    let expected_ciphertext: [u8; AES_BLOCK_SIZE] = [
        0x25, 0x15, 0x4c, 0x8f, 0x31, 0x76, 0xe3, 0x88, 0x66, 0xe2, 0x90, 0xec, 0xcf, 0xae, 0x7e,
        0x80,
    ];

    let ciphertext = aes_enc_block(&plaintext, &key).expect("Encryption failed");
    assert_eq!(ciphertext, expected_ciphertext);
}

#[test]
fn test_aes_enc_block_key_len_256() {
    let plaintext: [u8; AES_BLOCK_SIZE] = [
        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
        0x22,
    ];
    let key: [u8; AES_256_KEY_SIZE] = [
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee,
        0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd,
        0xee, 0xff,
    ];
    let expected_ciphertext: [u8; AES_BLOCK_SIZE] = [
        0x85, 0xc4, 0x0e, 0x69, 0x0b, 0x76, 0xde, 0x5b, 0x68, 0x48, 0x37, 0x16, 0x4c, 0xd8, 0xa1,
        0xab,
    ];

    let ciphertext = aes_enc_block(&plaintext, &key).expect("Encryption failed");
    assert_eq!(ciphertext, expected_ciphertext);
}

#[test]
fn test_aes_dec_block_key_len_128() {
    let expected_plaintext: [u8; AES_BLOCK_SIZE] = [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];
    let key: [u8; AES_128_KEY_SIZE] = [
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee,
        0xff,
    ];
    let ciphertext: [u8; AES_BLOCK_SIZE] = [
        0xfd, 0xe4, 0xfb, 0xae, 0x4a, 0x09, 0xe0, 0x20, 0xef, 0xf7, 0x22, 0x96, 0x9f, 0x83, 0x83,
        0x2b,
    ];

    let decrypted_plaintext = aes_dec_block(&ciphertext, &key).expect("Decryption failed");
    assert_eq!(decrypted_plaintext, expected_plaintext);
}

#[test]
fn test_aes_dec_block_key_len_192() {
    let expected_plaintext: [u8; AES_BLOCK_SIZE] = [
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
        0x11,
    ];
    let key: [u8; AES_192_KEY_SIZE] = [
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee,
        0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
    ];
    let ciphertext: [u8; AES_BLOCK_SIZE] = [
        0x25, 0x15, 0x4c, 0x8f, 0x31, 0x76, 0xe3, 0x88, 0x66, 0xe2, 0x90, 0xec, 0xcf, 0xae, 0x7e,
        0x80,
    ];

    let decrypted_plaintext = aes_dec_block(&ciphertext, &key).expect("Decryption failed");
    assert_eq!(decrypted_plaintext, expected_plaintext);
}

#[test]
fn test_aes_dec_block_key_len_256() {
    let expected_plaintext: [u8; AES_BLOCK_SIZE] = [
        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
        0x22,
    ];
    let key: [u8; AES_256_KEY_SIZE] = [
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee,
        0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd,
        0xee, 0xff,
    ];
    let ciphertext: [u8; AES_BLOCK_SIZE] = [
        0x85, 0xc4, 0x0e, 0x69, 0x0b, 0x76, 0xde, 0x5b, 0x68, 0x48, 0x37, 0x16, 0x4c, 0xd8, 0xa1,
        0xab,
    ];

    let decrypted_plaintext = aes_dec_block(&ciphertext, &key).expect("Decryption failed");
    assert_eq!(decrypted_plaintext, expected_plaintext);
}

#[test]
fn test_aes_enc_block_invalid_key_length() {
    let block: [u8; AES_BLOCK_SIZE] = [0u8; 16]; // Valid block size
    let invalid_key: [u8; 15] = [0u8; 15]; // Invalid key length

    let result = aes_enc_block(&block, &invalid_key);

    assert!(result.is_err());
    let error = result.err().unwrap();
    assert_eq!(
        error.to_string(),
        "AES CORE ERROR: Invalid key length. Expected 16, 24, or 32 bytes, got 15 bytes"
    );
}
